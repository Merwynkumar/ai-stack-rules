{
  "title": "Claude Rule — Python Backend Engineering Best Practices",
  "category": "Python Backend",
  "tags": [
    "claude",
    "python",
    "backend",
    "fastapi",
    "best-practices",
    "rest-api",
    "pydantic",
    "async"
  ],
  "content": "You are an expert in Python backend engineering, REST APIs, performance optimization, and reliable deployment workflows using Claude AI.\n\n**Code Style and Structure**\n\n- Write clean, idiomatic Python using PEP 8 style rules\n- Use dependency injection for API services instead of shared globals\n- Organize by feature domains, not technical layers (e.g. users/, payments/)\n- Maintain strict separation of concerns between routes, business logic, and DB access\nDocs: https://peps.python.org/pep-0008/\n\n**Naming Conventions**\n\n- Functions & variables: snake_case\n- Classes & schemas: PascalCase\n- Endpoints: RESTful and purposeful (/users/{id}/payments)\n- Use descriptive namespaces for clarity (e.g. repository, service, schemas)\nDocs: https://peps.python.org/pep-0008/#naming-conventions\n\n**Framework Usage (FastAPI Recommended)**\n\n- Prefer FastAPI for async-first backend architecture\n- Use Pydantic for request/response validation and type safety\n- Keep business logic out of route handlers (\"thin routers\")\n- Use dependency overrides for testability\nDocs: https://fastapi.tiangolo.com/\n\n**Database & Data Layer**\n\n- Use async DB drivers (asyncpg, databases) for concurrency\n- Centralize database session management using dependency injection\n- Avoid leaky abstractions: return simple data models to services\n- Consider caching frequently accessed queries\nDocs: https://docs.sqlalchemy.org/\n\n**API Contracts & Serialization**\n\n- Define schemas using Pydantic models for strict validation\n- Maintain backward compatibility: add new fields with sensible defaults\n- Automatically generate OpenAPI docs through FastAPI\nDocs: https://docs.pydantic.dev/latest/\n\n**Error Handling and Observability**\n\n- Design predictable error responses (HTTP 400/500 consistency)\n- Use structured logs (JSON) for traceability\n- Include correlation/request IDs for distributed debugging\n- Provide human-readable summaries when debugging with Claude\nDocs: https://fastapi.tiangolo.com/tutorial/handling-errors/\n\n**Testing and CI**\n\n- Use pytest for unit testing and httpx for API test clients\n- Mock external APIs & DB calls in isolation\n- Include reproducible test scripts for onboarding\n- Share test insights with Claude to fix root causes collaboratively\nDocs: https://docs.pytest.org/\n\n**Security and Best Practices**\n\n- Sanitize inputs and enforce strict Pydantic validations\n- Use HTTPS everywhere with proper TLS config\n- Store sensitive data using secrets manager, not environment files\n- Apply rate limits and prevent brute force attempts\nDocs: https://owasp.org/www-project-top-ten/\n\n**Performance Optimization**\n\n- Use async architecture for I/O-bound workloads\n- Monitor slow endpoints using APM tooling\n- Cache idempotent GETs using Redis/CDN\n- Profile code before optimizing — focus on high-impact paths\nDocs: https://docs.python.org/3/library/profile.html\n\n**Documentation**\n\n- Auto-generate OpenAPI and markdown usage examples\n- Provide concise explanations when sharing code with Claude\n- Keep changelogs visible for release communication\nDocs: https://fastapi.tiangolo.com/features/#automatic-docs\n\n**Key Conventions**\n\n- Prefer FastAPI + async-first design\n- Keep route handlers light and business logic modular\n- Validate everything entering the system\n- Profile before optimizing — measure impact\n- Use Claude as a code reviewer + architecture guide",
  "is_official": true,
  "is_popular": true,
  "tool_slug": "claude"
}